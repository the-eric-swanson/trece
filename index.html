<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trece</title>
    <style>
        :root { --bg: #2c2c2c; --panel: rgba(255,255,255,0.05); --card-bg: #ffffff; --accent: #d4d4d4; }
        body { font-family: sans-serif; background-color: var(--bg); color: var(--accent); display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; overflow-x: hidden; }
        #header { width: 100%; max-width: 800px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 15px; }
        #score-val { font-size: 2.2rem; color: white; transition: all 0.3s; display: block; }
        #top-bar { display: flex; justify-content: space-between; width: 702px; max-width: 95vw; margin-bottom: 40px;}
        .slot-group { display: flex; flex-direction: column; align-items: center; }
        .push-right { margin-right: auto; }
        .slot { width: 90px; height: 128px; border-radius: 4px; background: var(--panel); border: 1px solid rgba(255,255,255,0.08); position: relative; }
        .deck-back { width: 90px; height: 128px; background: #3d3d3d; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        
        #game-container { position: relative; width: fit-content; }
        #game-board { display: flex; gap: 12px; }
        .column { width: 90px; min-height: 450px; position: relative; }
        
        .card { width: 88px; height: 126px; background: var(--card-bg); color: #1a1a1a; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: 800; font-size: 2.2rem; cursor: pointer; position: absolute; box-shadow: 0 1px 3px rgba(0,0,0,0.2); user-select: none; transition: transform 0.2s, background-color 0.2s; }
        .card.facedown { background: #3d3d3d !important; border: 1px solid rgba(255,255,255,0.1); color: transparent !important; cursor: default; }
        .card.facedown * { visibility: hidden; }
        .card.selected { transform: translateY(-8px); outline: 4px solid #5c5c5c; z-index: 100 !important; }

        .card.error { outline: 4px solid #b71c1c; background-color: #ffdce0; animation: shake 0.4s; z-index: 101 !important; }
        @keyframes shake {
            0%, 100% { transform: translateX(0) translateY(-8px); }
            20%, 60% { transform: translateX(-6px) translateY(-8px); }
            40%, 80% { transform: translateX(6px) translateY(-8px); }
        }
        
        #end-screen, #rules-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); display: none; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; z-index: 1000; backdrop-filter: blur(4px); }
        #rules-screen { padding: 40px; text-align: left; align-items: flex-start; }
        #rules-content { max-width: 500px; margin: 0 auto; line-height: 1.6; }

        .controls { margin-top: 40px; display: flex; gap: 15px; }
        button { background: transparent; border: 1px solid rgba(255,255,255,0.2); color: var(--accent); padding: 12px 24px; cursor: pointer; text-transform: uppercase; font-weight: bold; }
        button:hover { border-color: white; color: white; }
        .btn-primary { background: white; color: black; border: none; margin-top: 20px; }
    </style>
    <link rel="manifest" href="manifest.json">
</head>
<body>
    <div id="header">
        <h1 style="font-weight: 200; letter-spacing: 5px;">TRECE</h1>
        <div>Score: <span id="score-val">0</span></div>
    </div>
    
    <div id="top-bar">
        <div style="display: flex; gap: 12px;"> <div class="slot-group">
                <div class="deck-back" onclick="drawCard()">
                    <span id="deck-n" style="font-size: 1.2rem; font-weight: bold;">52</span>
                </div>
            </div>
            <div class="slot-group">
                <div class="slot" id="discard-slot"></div>
            </div>
        </div>
    
        <div class="slot-group">
            <div class="slot" id="success-slot"></div>
        </div>
    </div>

    <div id="game-container">
        <div id="game-board">
            <div class="column" id="col-0"></div><div class="column" id="col-1"></div>
            <div class="column" id="col-2"></div><div class="column" id="col-3"></div>
            <div class="column" id="col-4"></div><div class="column" id="col-5"></div>
            <div class="column" id="col-6"></div>
        </div>

        <div id="end-screen">
            <h2 id="end-title"></h2>
            <p id="end-message"></p>
            <button class="btn-primary" onclick="initGame()">Next Round</button>
        </div>

        <div id="rules-screen" onclick="closeRules()">
            <div id="rules-content">
                <h3>How to Play Trece</h3>
                <ul>
                    <li><strong>Goal:</strong> Clear all cards from the Tableau columns.</li>
                    <li><strong>Pairs:</strong> Select two cards that add up to <strong>13</strong> (e.g., 8+5, 10+3).</li>
                    <li><strong>Values:</strong> J=11, Q=12, K=13 (Kings clear solo). Aces=1.</li>
                    <li><strong>Face Down:</strong> Cards are revealed when the card covering them is cleared.</li>
                    <li><strong>Scoring:</strong> Clearing a round adds 5 points + remaining cards in the deck.</li>
                </ul>
                <p style="font-size: 0.8rem; opacity: 0.6;">(Click anywhere to close)</p>
            </div>
        </div>
    </div>

    <div class="controls">
        <button onclick="showRules()">Rules</button>
        <button onclick="initGame()">Restart Round</button>
        <button onclick="resetSession()">Reset Session</button>
    </div>

    <script>
        let deck = [], selectedCard = null, sessionScore = 0, roundEnded = false;

        function initGame() {
            deck = []; selectedCard = null; roundEnded = false;
            document.getElementById('end-screen').style.display = 'none';
            document.getElementById('rules-screen').style.display = 'none';
            const suits = ['♠', '♥', '♦', '♣'], names = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            for (let s of suits) for (let i = 0; i < names.length; i++) deck.push({ n: names[i], v: i + 1, s: s });
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            clearUI();
            for (let i = 0; i < 7; i++) for (let j = 0; j <= i; j++) renderCard(deck.pop(), 'col-' + i, j * 28, (j < i));
            updateUI();
        }

        function clearUI() {
            for (let i = 0; i < 7; i++) document.getElementById('col-' + i).innerHTML = '';
            ['active-slot', 'discard-slot', 'success-slot'].forEach(id => document.getElementById(id).innerHTML = '');
        }

        function showRules() { document.getElementById('rules-screen').style.display = 'flex'; }
        function closeRules() { document.getElementById('rules-screen').style.display = 'none'; }

        function renderCard(data, containerId, topPos, isFacedown = false) {
            const div = document.createElement('div');
            div.className = 'card' + (isFacedown ? ' facedown' : '');
            div.dataset.v = data.v;
            div.style.top = topPos + "px";
            div.innerHTML = '<div style="margin-bottom:-10px">' + data.n + '</div><div style="font-size:2.5rem">' + data.s + '</div>';
            if (data.s === '♥' || data.s === '♦') div.style.color = '#b71c1c';
            
            div.onclick = function() {
                if (roundEnded || div.classList.contains('facedown') || div.nextElementSibling || div.parentElement.id === 'success-slot') return;
                
                const val = parseInt(div.dataset.v);
                
                if (val === 13) { 
                    if (navigator.vibrate) navigator.vibrate([40, 40]); // Subtle success tap
                    moveToSuccess(div); 
                    return; 
                }
                
                if (!selectedCard) { 
                    selectedCard = div; 
                    div.classList.add('selected'); 
                } 
                else {
                    if (selectedCard === div) { 
                        div.classList.remove('selected'); 
                        selectedCard = null; 
                    }
                    else if (parseInt(selectedCard.dataset.v) + val === 13) {
                        if (navigator.vibrate) navigator.vibrate([40, 40]); // Subtle success tap
                        moveToSuccess(selectedCard); 
                        moveToSuccess(div); 
                        selectedCard = null;
                    } 
                    else {
                        const c1 = selectedCard, c2 = div;
                        if (navigator.vibrate) navigator.vibrate(200); // Error thump
                        c1.classList.add('error'); 
                        c2.classList.add('error');
                        setTimeout(() => { 
                            c1.classList.remove('error', 'selected'); 
                            c2.classList.remove('error'); 
                        }, 400);
                        selectedCard = null;
                    }
                }
            };
            document.getElementById(containerId).appendChild(div);
        }

        function drawCard() {
            if (deck.length === 0 || roundEnded) { 
                checkGameState(); 
                return; 
            }
            
            const discard = document.getElementById('discard-slot');
            
            // Create the new card from the deck
            // We render it directly into the discard slot
            renderCard(deck.pop(), 'discard-slot', discard.children.length * 1, false);
            
            updateUI();
            checkGameState();
        }

        function moveToSuccess(el) {
            const parent = el.parentElement;
            el.classList.remove('selected');
            const succ = document.getElementById('success-slot');
            
            // Stack cards slightly in success pile
            el.style.top = (succ.children.length * 1) + "px";
            succ.appendChild(el);
            
            // 1. If it came from a Tableau Column, flip the card underneath
            if (parent.classList.contains('column') && parent.children.length > 0) {
                const newBottom = parent.lastElementChild;
                if (newBottom.classList.contains('facedown')) {
                    newBottom.classList.remove('facedown');
                }
            }
    
    // 2. Note: If it came from Discard, the card beneath it 
    // is automatically revealed and playable because of our 
    // click logic (only lastElementChild is clickable).

         setTimeout(checkGameState, 300);
    }

        function updateUI() { document.getElementById('deck-n').innerText = deck.length; }

        function checkGameState() {
            if (roundEnded) return;
            const tableauCards = document.querySelectorAll('.column .card').length;
            if (tableauCards === 0) { showEndScreen(true); return; }
            if (deck.length === 0) {
                const playable = Array.from(document.querySelectorAll('.card')).filter(c => !c.classList.contains('facedown') && !c.nextElementSibling && c.parentElement.id !== 'success-slot');
                let hasMove = false;
                for (let i = 0; i < playable.length; i++) {
                    let v1 = parseInt(playable[i].dataset.v);
                    if (v1 === 13) hasMove = true;
                    for (let j = i + 1; j < playable.length; j++) {
                        if (v1 + parseInt(playable[j].dataset.v) === 13) hasMove = true;
                    }
                }
                if (!hasMove) showEndScreen(false);
            }
        }

        function showEndScreen(isWin) {
            roundEnded = true;
            const screen = document.getElementById('end-screen');
            if (isWin) {
                let bonus = 5 + deck.length;
                sessionScore += bonus;
                document.getElementById('end-title').innerText = "VICTORY";
                document.getElementById('end-title').style.color = "#4caf50";
                document.getElementById('end-message').innerText = "Tableau Cleared! Bonus: +" + bonus;
            } else {
                const penalty = document.querySelectorAll('.card:not(#success-slot .card)').length;
                sessionScore -= penalty;
                document.getElementById('end-title').innerText = "GAME OVER";
                document.getElementById('end-title').style.color = "#f44336";
                document.getElementById('end-message').innerText = "No moves left. Penalty: -" + penalty;
            }
            document.getElementById('score-val').innerText = sessionScore;
            updateUI();
            screen.style.display = 'flex';
        }

        function resetSession() { sessionScore = 0; document.getElementById('score-val').innerText = "0"; initGame(); }
        window.onload = initGame;
    </script>
</body>
</html>